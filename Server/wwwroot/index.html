<!DOCTYPE html>
<html>
<head>
    <title>Little Buddy Dashboard</title>
    <style>
        .user-container {
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .user-header {
            margin-bottom: 10px;
            padding: 5px;
            background-color: #f5f5f5;
        }
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .chart {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
            height: 300px;
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <div id="active-users">Active Users: None</div>
    </div>
    <div id="users-container"></div>
    <div id="messages"></div>

    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const userCharts = new Map();
        
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/hubs/payload/")
            .build();

        connection.on("ReceivePayload", (payload) => {
            const messagesDiv = document.getElementById("messages");
            const messageElement = document.createElement("div");
            messageElement.textContent = `${payload}`;
            messagesDiv.appendChild(messageElement);
            messagesDiv.appendChild(document.createElement("br"));

            const payloadData = JSON.parse(payload);
            const buddyDevices = payloadData.map(device => BuddyDevice.fromJson(device));
            
            buddyDevices.forEach(device => {
                if (!userCharts.has(device.username)) {
                    createUserContainer(device.username, device.sensors.length);
                }
                updateCharts(device);
                updateActiveUsers();
            });
        });

        function createUserContainer(username, sensorCount) {
            const usersContainer = document.getElementById('users-container');
            
            const userContainer = document.createElement('div');
            userContainer.className = 'user-container';
            userContainer.id = `user-${username}`;
            
            const userHeader = document.createElement('div');
            userHeader.className = 'user-header';
            userHeader.innerHTML = `User: ${username}`;
            
            const chartsContainer = document.createElement('div');
            chartsContainer.className = 'chart-container';
            
            const chartConfigs = {};
            // Create charts based on actual sensor count
            for (let i = 1; i <= sensorCount; i++) {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart';
                
                const canvas = document.createElement('canvas');
                canvas.id = `chart-${username}-${i}`;
                chartDiv.appendChild(canvas);
                chartsContainer.appendChild(chartDiv);
                
                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: `Sensor ${i} Readings`,
                            data: [],
                            borderWidth: 1,
                            borderColor: `hsl(${(i * 60) % 360}, 70%, 50%)`, // Different color for each sensor
                            backgroundColor: `hsla(${(i * 60) % 360}, 70%, 50%, 0.2)`
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: false
                            }
                        },
                        animation: {
                            duration: 0
                        },
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
                
                chartConfigs[i] = chart;
            }
            
            userContainer.appendChild(userHeader);
            userContainer.appendChild(chartsContainer);
            usersContainer.appendChild(userContainer);
            
            userCharts.set(username, chartConfigs);
        }

        function updateCharts(buddyDevice) {
            let charts = userCharts.get(buddyDevice.username);
            if (!charts) return;

            // Check if we need to create new charts
            const currentSensorCount = Object.keys(charts).length;
            if (buddyDevice.sensors.length > currentSensorCount) {
                const userContainer = document.getElementById(`user-${buddyDevice.username}`);
                const chartsContainer = userContainer.querySelector('.chart-container');
                
                for (let i = currentSensorCount + 1; i <= buddyDevice.sensors.length; i++) {
                    const chartDiv = document.createElement('div');
                    chartDiv.className = 'chart';
                    
                    const canvas = document.createElement('canvas');
                    canvas.id = `chart-${buddyDevice.username}-${i}`;
                    chartDiv.appendChild(canvas);
                    chartsContainer.appendChild(chartDiv);
                    
                    const ctx = canvas.getContext('2d');
                    const chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: `Sensor ${i} Readings`,
                                data: [],
                                borderWidth: 1,
                                borderColor: `hsl(${(i * 60) % 360}, 70%, 50%)`,
                                backgroundColor: `hsla(${(i * 60) % 360}, 70%, 50%, 0.2)`
                            }]
                        },
                        options: {
                            scales: {
                                y: {
                                    beginAtZero: false
                                }
                            },
                            animation: {
                                duration: 0
                            },
                            responsive: true,
                            maintainAspectRatio: false
                        }
                    });
                    
                    charts[i] = chart;
                }
                
                userCharts.set(buddyDevice.username, charts);
            }

            buddyDevice.sensors.forEach(sensor => {
                const chart = charts[sensor.sensorId];
                if (!chart) return;

                const readings = sensor.getReadingHistory();
                chart.data.labels = readings.map(r => r.timestamp.toLocaleTimeString());
                chart.data.datasets[0].data = readings.map(r => r.value);
                chart.update();
            });
        }

        function updateActiveUsers() {
            const activeUsersElement = document.getElementById('active-users');
            const userCount = userCharts.size;
            activeUsersElement.textContent = `Active Users: ${userCount === 0 ? 'None' : Array.from(userCharts.keys()).join(', ')}`;
        }

        // Reading, Sensor, and BuddyDevice classes
        class Reading {
            constructor(timestamp, value) {
                this.timestamp = new Date(timestamp);
                this.value = value;
            }
    
            static fromJson(json) {
                return new Reading(json.Timestamp, json.Value);
            }
        }

        class Sensor {
            constructor(sensorId, readings = []) {
                this.sensorId = sensorId;
                this.readings = readings;
            }
    
            static fromJson(json) {
                const readings = json.Readings.map(reading => Reading.fromJson(reading));
                return new Sensor(json.SensorID, readings);
            }
    
            getLatestReading() {
                if (this.readings.length === 0) return null;
                return this.readings[this.readings.length - 1];
            }
    
            getReadingHistory() {
                return this.readings.map(reading => ({
                    timestamp: reading.timestamp,
                    value: reading.value
                }));
            }
        }
    
        class BuddyDevice {
            constructor(deviceId, username, sensors = []) {
                this.deviceId = deviceId;
                this.username = username;
                this.sensors = sensors;
            }
    
            static fromJson(json) {
                const sensors = json.BuddyDevice.map(sensor => Sensor.fromJson(sensor));
                return new BuddyDevice(json.DeviceID, json.Username, sensors);
            }
    
            getSensorById(id) {
                return this.sensors.find(sensor => sensor.sensorId === id);
            }
    
            getAllSensorsLatestReadings() {
                return this.sensors.map(sensor => ({
                    sensorId: sensor.sensorId,
                    reading: sensor.getLatestReading()
                }));
            }
        }

        connection.start().catch(err => console.error(err.toString()));
    </script>
</body>
</html>